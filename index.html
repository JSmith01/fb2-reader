<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>FB2 Reader</title>
    <style>
        body {
            margin: 0;
            background: beige;
        }
        .book-wrapper {
            columns: 2;
            height: 80vh;
            overflow-y: hidden;
            overflow-x: scroll;
            column-gap: 20px;
        }
        .book-wrapper section,
        .book-wrapper p,
        .book-wrapper p {
            font-size: 18px;
            line-height: 1.5;
        }
        .image-block {
            text-align: center;
            break-inside: avoid-column;
            page-break-inside: avoid;
        }
        .image-block img {
            object-fit: contain;
            width: 80%;
            max-height: 70vh;
        }
        input#f {
            position: absolute;
            top: 0;
            left: 0;
        }
        .book-info-trigger {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 15px;
            z-index: 5;
        }
        .book-info {
            display: none;
            position: absolute;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            height: auto;
            color: white;
        }
        .book-info-trigger:hover + .book-info, .book-info:hover {
            display: block;
        }
    </style>
</head>
<body>
<input type="file" accept=".fb2, .zip" id="f">
<script src="unzipit.min.js"></script>
<script>
    unzipit.setOptions({
        workerURL: 'unzipit-worker.min.js',
        numWorkers: 2,
    });
</script>
<script>
    const fEl = document.getElementById('f');
    const defaultEncoding = 'utf-8';
    let xml;

    function stripTags(text) {
        const t = document.createElement('div');
        t.innerHTML = text;
        return t.innerText;
    }

    function parseAuthor(author) {
        const info = {};
        Array.from(author.children).forEach(child => {
            info[child.nodeName] = stripTags(child.innerHTML);
        });
        if (info['first-name'] && info['last-name']) {
            return [info['first-name'],  info['middle-name'], info['last-name']].filter(Boolean).join(' ');
        } else if (info['nickname']) {
            return info['nickname'];
        } else return '';
    }

    function getMeta(xml) {
        const titleInfo = xml.querySelector('description>title-info');
        const annotation = titleInfo.getElementsByTagName('annotation')[0];
        const title = stripTags(titleInfo.getElementsByTagName('book-title')[0].innerHTML);
        const authors = Array.from(titleInfo.getElementsByTagName('author')).map(parseAuthor);
        const sequence = titleInfo.getElementsByTagName('sequence')[0];
        const sequenceName = sequence?.attributes.name?.value;
        const sequenceNumber = sequence?.attributes.number?.value;

        return { title, authors, annotation, sequenceName, sequenceNumber };
    }

    function showBookContents(xml) {
        const meta = getMeta(xml);
        const t = document.createElement('div');
        t.innerHTML = `
<div class="book-info-trigger"></div><div class="book-info">
<div>Автор${meta.authors.length > 1 ? 'ы' : ''}: ${meta.authors.join(', ')}</div>
<div>Название: ${meta.title}</div>
${meta.sequenceName ? `<div>Серия: ${meta.sequenceName}, том ${meta.sequenceNumber}</div>` : ''}
<div class="book-annotation">${meta.annotation.innerHTML}</div></div>`;

        document.body.appendChild(t);

        return renderBook(xml);
    }

    function getImageContentType(b64str) {
        let prepared = b64str.substring(0, 40).trim();
        prepared = prepared.substring(0, prepared.length - prepared.length % 4);
        if (prepared.length < 4) return 'image/unknown'; // fallback, let the browser decide
        const bin = atob(prepared);
        if (bin.startsWith('GIF89a')) return 'image/gif';
        if (bin.startsWith('\x89PNG\r\n\x1a\n')) return 'image/png';
        if (bin.startsWith('\xff\xd8\xff\xe0')) return 'image/jpeg';
        if (bin.startsWith('\x49\x49\x2A\x00') || bin.startsWith('\x4D\x4D\x00\x2A')) return 'image/tiff';
        if (bin.startsWith('\x52\x49\x46\x46')) return 'image/webp';
        return 'image/unknown';
    }

    const imageSrcCache = new WeakMap();

    function getImageSrc(binary) {
        if (imageSrcCache.has(binary)) return imageSrcCache.get(binary);

        const contentType = binary.attributes['content-type']?.value ?? getImageContentType(binary.innerHTML);
        const data = `data:${contentType};base64, ` + binary.innerHTML
        imageSrcCache.set(binary, data);

        return data;
    }

    function getImage(binary) {
        const img = document.createElement('img');
        img.src = getImageSrc(binary);
        img.id = binary.attributes.id.value;

        return img;
    }

    const readFileAsText = (file, encoding = defaultEncoding) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener('error', reject);
        reader.addEventListener('load', () => resolve(reader.result));
        reader.readAsText(file, encoding);
    });

    async function getFb2Encoding(file) {
        const initBlock = file.slice(0, 300);
        const initText = await readFileAsText(initBlock);
        const firstLine = initText.split('\n')[0];
        if (!firstLine || !firstLine.startsWith('<?xml')) {
            throw new DOMException('Non-XML document detected', 'NONXML');
        }
        const match = firstLine.match(/encoding="([^"]+)"/);
        if (match) {
            const encoding = match[1];
            return encoding.toLowerCase();
        } else {
            return defaultEncoding;
        }
    }

    async function readFb2File(file) {
        const encoding = await getFb2Encoding(file);
        const content = await readFileAsText(file, encoding);

        return new DOMParser().parseFromString(content, 'application/xml');
    }

    async function unzipFb2(file) {
        const { entries } = await unzipit.unzip(file);
        const fb2FileName = Object.keys(entries).find(name => name.endsWith('.fb2'));
        if (!fb2FileName) throw new DOMException('No FB2 inside zip', 'ZIP-NONFB2');

        return entries[fb2FileName].blob();
    }

    async function processFile(file) {
        const fb2File = file.name.endsWith('.zip') ? await unzipFb2(file) : file;
        xml = await readFb2File(fb2File);
        if (!xml.querySelector('FictionBook')) throw new DOMException('Non-FB2 document detected', 'NONFB2');

        await showBookContents(xml);
    }

    fEl.addEventListener('change', () => {
        if (fEl.files.length === 0) return;
        processFile(fEl.files[0]).then(() => {
            fEl.style.visibility = 'hidden';
        }, e => {
            console.log(e);
            alert(e.message);
        })
    });

    function loadXml(url) {
        return new Promise((resolve, reject) => {
            const req = new XMLHttpRequest();
            req.addEventListener('load', e => resolve(req.responseXML));
            req.open('GET', url);
            req.responseType = 'document';
            req.send();
        });
    }

    let xsltProcessor;
    async function parseFb2ToHtml(xml) {
        if (!xsltProcessor) {
            xsltProcessor = new XSLTProcessor();
            xsltProcessor.importStylesheet(await loadXml('fb2-html.xsl'));
        }

        return xsltProcessor.transformToDocument(xml);
    }

    /**
     * 1. Load Fb2
     * 2. Parse to html -> doc = parseFb2ToHtml(xml)
     * 3. Replace img to correct inline images
     * 4. Create wrapper and append to DOM
     * 5. Move all from "doc.body.children" to wrapper
     */
    async function renderBook(xml) {
        const doc = await parseFb2ToHtml(xml);

        const images = doc.querySelectorAll('img[data-src]');
        const binaries = Array.from(xml.getElementsByTagName('binary'));
        const binariesMap = Object.fromEntries(binaries.map(binary => [binary.id, binary]));

        images.forEach(image => {
            image.src = getImageSrc(binariesMap[image.dataset.src]);
        });

        const htmlBook = doc.body.firstChild;

        document.body.appendChild(htmlBook);

        return htmlBook;
    }
</script>
</body>
</html>

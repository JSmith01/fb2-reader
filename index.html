<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>FB2 Reader</title>
    <link rel="stylesheet" href="main.css">
</head>
<body>

<footer>Page <span id="curPage">0</span> of <span id="totalPages">0</span> (<span id="curPercent">0</span>%)</footer>
<input type="file" accept=".fb2, .zip" id="f">
<div id="book"></div>

<script src="unzipit.min.js"></script>

<script>
    unzipit.setOptions({
        workerURL: 'unzipit-worker.min.js',
        numWorkers: 2,
    });
</script>
<script>
    const fEl = document.getElementById('f');
    const bookEl = document.getElementById('book');
    const defaultEncoding = 'utf-8';
    let xml;

    function stripTags(text) {
        const t = document.createElement('div');
        t.innerHTML = text;
        return t.innerText;
    }

    function parseAuthor(author) {
        const info = {};
        Array.from(author.children).forEach(child => {
            info[child.nodeName] = stripTags(child.innerHTML);
        });
        if (info['first-name'] && info['last-name']) {
            return [info['first-name'],  info['middle-name'], info['last-name']].filter(Boolean).join(' ');
        } else if (info['nickname']) {
            return info['nickname'];
        } else return '';
    }

    function getMeta(xml) {
        const titleInfo = xml.querySelector('description>title-info');
        const annotation = titleInfo.getElementsByTagName('annotation')[0];
        const title = stripTags(titleInfo.getElementsByTagName('book-title')[0].innerHTML);
        const authors = Array.from(titleInfo.getElementsByTagName('author')).map(parseAuthor);
        const sequence = titleInfo.getElementsByTagName('sequence')[0];
        const sequenceName = sequence?.attributes.name?.value;
        const sequenceNumber = sequence?.attributes.number?.value;

        return { title, authors, annotation, sequenceName, sequenceNumber };
    }

    function showBookContents(xml) {
        const meta = getMeta(xml);
        const t = document.createElement('div');
        t.innerHTML = `
<div class="book-info-trigger"></div><div class="book-info">
<div>Автор${meta.authors.length > 1 ? 'ы' : ''}: ${meta.authors.join(', ')}</div>
<div>Название: ${meta.title}</div>
${meta.sequenceName ? `<div>Серия: ${meta.sequenceName}, том ${meta.sequenceNumber}</div>` : ''}
<div class="book-annotation">${meta.annotation.innerHTML}</div></div>`;

        document.body.appendChild(t);

        return renderBook(xml);
    }

    function getImageContentType(b64str) {
        let prepared = b64str.substring(0, 40).trim();
        prepared = prepared.substring(0, prepared.length - prepared.length % 4);
        if (prepared.length < 4) return 'image/unknown'; // fallback, let the browser decide
        const bin = atob(prepared);
        if (bin.startsWith('GIF89a')) return 'image/gif';
        if (bin.startsWith('\x89PNG\r\n\x1a\n')) return 'image/png';
        if (bin.startsWith('\xff\xd8\xff\xe0')) return 'image/jpeg';
        if (bin.startsWith('\x49\x49\x2A\x00') || bin.startsWith('\x4D\x4D\x00\x2A')) return 'image/tiff';
        if (bin.startsWith('\x52\x49\x46\x46')) return 'image/webp';
        return 'image/unknown';
    }

    const imageSrcCache = new WeakMap();

    function getImageSrc(binary) {
        if (imageSrcCache.has(binary)) return imageSrcCache.get(binary);

        const contentType = binary.attributes['content-type']?.value ?? getImageContentType(binary.innerHTML);
        const data = `data:${contentType};base64, ` + binary.innerHTML
        imageSrcCache.set(binary, data);

        return data;
    }

    function getImage(binary) {
        const img = document.createElement('img');
        img.src = getImageSrc(binary);
        img.id = binary.attributes.id.value;

        return img;
    }

    const readFileAsText = (file, encoding = defaultEncoding) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener('error', reject);
        reader.addEventListener('load', () => resolve(reader.result));
        reader.readAsText(file, encoding);
    });

    async function getFb2Encoding(file) {
        const initBlock = file.slice(0, 300);
        const initText = await readFileAsText(initBlock);
        const firstLine = initText.split('\n')[0];
        if (!firstLine || !firstLine.startsWith('<?xml')) {
            throw new DOMException('Non-XML document detected', 'NONXML');
        }
        const match = firstLine.match(/encoding="([^"]+)"/);
        if (match) {
            const encoding = match[1];
            return encoding.toLowerCase();
        } else {
            return defaultEncoding;
        }
    }

    async function readFb2File(file) {
        const encoding = await getFb2Encoding(file);
        const content = await readFileAsText(file, encoding);

        return new DOMParser().parseFromString(content, 'application/xml');
    }

    async function unzipFb2(file) {
        const { entries } = await unzipit.unzip(file);
        const fb2FileName = Object.keys(entries).find(name => name.endsWith('.fb2'));
        if (!fb2FileName) throw new DOMException('No FB2 inside zip', 'ZIP-NONFB2');

        return entries[fb2FileName].blob();
    }

    async function processFile(file) {
        const fb2File = file.name.endsWith('.zip') ? await unzipFb2(file) : file;
        xml = await readFb2File(fb2File);
        if (!xml.querySelector('FictionBook')) throw new DOMException('Non-FB2 document detected', 'NONFB2');

        return showBookContents(xml);
    }

    let bookPosition;
    fEl.addEventListener('change', () => {
        if (fEl.files.length === 0) return;
        processFile(fEl.files[0]).then(htmlBook => {
            fEl.style.visibility = 'hidden';
            bookPosition = new BookPosition(htmlBook);
            window.addEventListener('keyup', pageControl);
            setTimeout(() => {
                bookPosition.calcPagination();
                updateFooter();
            }, 20);
        }, e => {
            console.log(e);
            alert(e.message);
        })
    });

    function updateFooter() {
        const totalPages = bookPosition.getTotalPages();
        const currentPage = bookPosition.getCurrentPage() + 1;
        const percentage = (currentPage - 1) / Math.max(1, totalPages - 1) * 100;
        document.getElementById('totalPages').innerText = totalPages;
        document.getElementById('curPage').innerText = currentPage;
        document.getElementById('curPercent').innerText = percentage.toFixed(1);
    }

    function pageControl(e) {
        function go(delta) {
            e.preventDefault();
            e.stopPropagation();
            let page = bookPosition.getCurrentPage();
            const pagesPerSpread = bookPosition.getPagesPerSpread();
            bookPosition.goToPage(page + delta * pagesPerSpread);
            updateFooter();
        }

        switch (e.key) {
            case 'PageUp': return go(-1);
            case 'PageDown': return go(1);
            case 'Home': return go(-Infinity);
            case 'End': return go(+Infinity);
        }
    }

    function loadXml(url) {
        return new Promise((resolve, reject) => {
            const req = new XMLHttpRequest();
            req.addEventListener('load', e => resolve(req.responseXML));
            req.open('GET', url);
            req.responseType = 'document';
            req.send();
        });
    }

    let xsltProcessor;
    async function parseFb2ToHtml(xml) {
        if (!xsltProcessor) {
            xsltProcessor = new XSLTProcessor();
            xsltProcessor.importStylesheet(await loadXml('fb2-html.xsl'));
        }

        return xsltProcessor.transformToDocument(xml);
    }

    async function renderBook(xml) {
        const doc = await parseFb2ToHtml(xml);

        const images = doc.querySelectorAll('img[data-src]');
        const binaries = Array.from(xml.getElementsByTagName('binary'));
        const binariesMap = Object.fromEntries(binaries.map(binary => [binary.id, binary]));

        images.forEach(image => {
            image.src = getImageSrc(binariesMap[image.dataset.src]);
        });

        const htmlBook = doc.body.firstChild;

        bookEl.appendChild(htmlBook);

        return htmlBook;
    }

    class BookPosition {
        bookSpreadSize = 0;
        gap = 20;
        /** @type {HTMLElement} */
        htmlBook = null;
        currentBookSpread = 0;
        totalPages = 0;
        bookSpreads = 0;
        columnsOnPage = 2;

        constructor(htmlBook, columnsOnPage = 2) {
            this.htmlBook = htmlBook;
            this.columnsOnPage = columnsOnPage || 2;
        }

        getCurrentPage() {
            return this.currentBookSpread * this.columnsOnPage;
        }

        getPagesPerSpread() {
            return this.columnsOnPage;
        }

        getTotalPages() {
            return this.totalPages;
        }

        updatePageDims() {
            this.bookSpreadSize = this.htmlBook.getBoundingClientRect().width;
            const gapFromStyle = parseInt(window.getComputedStyle(this.htmlBook).columnGap);
            if (gapFromStyle > 0) this.gap = gapFromStyle;
        }

        calcPagination() {
            this.updatePageDims();
            const rawBookSpreads = (this.htmlBook.scrollWidth + this.gap) / (this.bookSpreadSize + this.gap);
            this.totalPages = Math.ceil(rawBookSpreads * this.columnsOnPage);
            this.bookSpreads = Math.ceil(rawBookSpreads);
            this._applyBookSpreadLimits();
        }

        adjustScrollPosition() {
            this.htmlBook.scrollLeft = this.currentBookSpread * (this.bookSpreadSize + this.gap);
        }

        _applyBookSpreadLimits() {
            if (this.currentBookSpread > this.bookSpreads - 1) {
                this.currentBookSpread = this.bookSpreads - 1;
            }
            if (this.currentBookSpread < 0) {
                this.currentBookSpread = 0;
            }
        }

        goToPage(n) {
            if (n != null) {
                this.currentBookSpread = Math.floor(n / this.columnsOnPage);
                this._applyBookSpreadLimits();
            } else {
                this.calcPagination();
            }

            this.adjustScrollPosition();

            return this.currentBookSpread * this.columnsOnPage;
        }
    }
</script>
</body>
</html>
